// Copyright 2019 Honey Science Corporation
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, you can obtain one at http://mozilla.org/MPL/2.0/.

// +build !integration

package workflow

import (
	"runtime"
	"testing"
	"time"

	"github.com/ghodss/yaml"
	"github.com/golang/mock/gomock"
	"github.com/honeydipper/honeydipper/internal/config"
	"github.com/honeydipper/honeydipper/internal/daemon"
	"github.com/honeydipper/honeydipper/internal/workflow/mock_workflow"
	"github.com/honeydipper/honeydipper/pkg/dipper"
	"github.com/stretchr/testify/assert"
)

func TestSessionHooks(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	mockHelper := mock_workflow.NewMockSessionStoreHelper(ctrl)
	s := NewSessionStore(mockHelper)

	// tear down
	defer delete(dipper.IDMapMetadata, &s.sessions)

	// every test case has following fields
	// - workflow: an workflow object to be executed using StartSession call
	// - msg:      an event message to be passed to initiate the workflow session
	// - ctx:      the ctx generated by the event used for initiating the workflow
	// - asserts:  a func() to be called to assert the success or failure of the test
	//             after an initial message is send out from the session
	//
	// - steps:    during the execution, multiple msgs are passed in and out of the session
	//             each step contains following
	//
	//   * msg:        the message to be passed into the session as using ContinueSession call
	//   * sessionID:  the sessionID used to match message with a session
	//   * ctx:        the exported ctx from the function call
	//   * asserts:    a func() to assert the success of failure of the test after sending
	//                 the message
	//

	hookTestCases := []map[string]interface{}{
		{ // test #1 -- triggering on_first_action
			"workflow": &config.Workflow{Steps: []config.Workflow{}},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_first_action": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(gomock.Eq(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "2",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "",
							"resume_token": "//0",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "bar",
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "2",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "2",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #2 -- skipping hook when condition not met
			"workflow": &config.Workflow{If: []string{"false"}},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_first_action": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(gomock.Any()).Times(0)
			},
			"steps": []map[string]interface{}{},
		},

		{ // test #3 -- triggering on_exit
			"workflow": &config.Workflow{},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_exit": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "5",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "",
							"resume_token": "//3",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "bar",
						},
						"labels": map[string]string{
							"status": "success",
						},
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "5",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "2",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #4 -- triggering on_success
			"workflow": &config.Workflow{},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_success": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "8",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "",
							"resume_token": "//6",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "bar",
						},
						"labels": map[string]string{
							"status": "success",
						},
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "8",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "2",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #5 -- triggering on_failure
			"workflow": &config.Workflow{CallDriver: "foo.failure"},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_failure": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "9",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo.failure",
							"resume_token": "//9",
							"hooks": map[string]interface{}{
								"on_failure": "send_chat",
							},
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "failure",
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "9",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "9",
							"status":    "failure",
							"reason":    "testing hook on failure",
						},
					},
					"ctx": []map[string]interface{}{},
					"asserts": func() {
						mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
							Channel: "eventbus",
							Subject: "command",
							Labels: map[string]string{
								"sessionID": "11",
							},
							Payload: map[string]interface{}{
								"ctx": map[string]interface{}{
									"_meta_desc":   "",
									"_meta_name":   "foo.failure",
									"resume_token": "//9",
								},
								"data":  map[string]interface{}{},
								"event": map[string]interface{}{},
								"function": config.Function{
									Driver:    "foo",
									RawAction: "bar",
								},
								"labels": map[string]string{
									"sessionID":  "9",
									"status":     "failure",
									"reason":     "testing hook on failure",
									"performing": "driver foo.failure",
								},
							},
						})).Times(1)
					},
				},
				{
					"sessionID": "11",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "11",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #6 -- triggering on_error
			"workflow": &config.Workflow{CallDriver: "foo.error"},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_failure": "send_chat_failure",
					"on_error":   "send_chat",
					"on_success": "send_chat_success",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "12",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "foo.error",
							"resume_token": "//12",
							"hooks": map[string]interface{}{
								"on_failure": "send_chat_failure",
								"on_error":   "send_chat",
								"on_success": "send_chat_success",
							},
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "error",
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "12",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "12",
							"status":    "error",
							"reason":    "testing hook on error",
						},
					},
					"ctx": []map[string]interface{}{},
					"asserts": func() {
						mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
							Channel: "eventbus",
							Subject: "command",
							Labels: map[string]string{
								"sessionID": "14",
							},
							Payload: map[string]interface{}{
								"ctx": map[string]interface{}{
									"_meta_desc":   "",
									"_meta_name":   "foo.error",
									"resume_token": "//12",
								},
								"data":  map[string]interface{}{},
								"event": map[string]interface{}{},
								"function": config.Function{
									Driver:    "foo",
									RawAction: "bar",
								},
								"labels": map[string]string{
									"sessionID":  "12",
									"status":     "error",
									"reason":     "testing hook on error",
									"performing": "driver foo.error",
								},
							},
						})).Times(1)
					},
				},
				{
					"sessionID": "14",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "14",
							"status":    "success",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},

		{ // test #7 -- testing with failed hook
			"workflow": &config.Workflow{Steps: []config.Workflow{}},
			"msg":      &dipper.Message{},
			"ctx": map[string]interface{}{
				"hooks": map[string]interface{}{
					"on_first_action": "send_chat",
				},
			},
			"asserts": func() {
				mockHelper.EXPECT().SendMessage(EqVal(&dipper.Message{
					Channel: "eventbus",
					Subject: "command",
					Labels: map[string]string{
						"sessionID": "17",
					},
					Payload: map[string]interface{}{
						"ctx": map[string]interface{}{
							"_meta_desc":   "",
							"_meta_name":   "",
							"resume_token": "//15",
						},
						"data":  map[string]interface{}{},
						"event": map[string]interface{}{},
						"function": config.Function{
							Driver:    "foo",
							RawAction: "bar",
						},
						"labels": emptyLabels,
					},
				})).Times(1)
			},
			"steps": []map[string]interface{}{
				{
					"sessionID": "17",
					"msg": &dipper.Message{
						Channel: "eventbus",
						Subject: "return",
						Labels: map[string]string{
							"sessionID": "17",
							"status":    "failure",
						},
					},
					"ctx": []map[string]interface{}{},
				},
			},
		},
	}

	configStr := `
---
workflows:
  send_chat:
    call_driver: foo.bar
`

	testDataSet := &config.DataSet{}
	err := yaml.UnmarshalStrict([]byte(configStr), testDataSet, yaml.DisallowUnknownFields)
	assert.Nil(t, err, "test config")
	testConfig := &config.Config{DataSet: testDataSet}

	var step int
	var baseLineNumGoRoutine int
	var testcase map[string]interface{}
	var teststep map[string]interface{}
	var casenum int

	testStartFunc := func() {
		step = -1
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.StartSession(testcase["workflow"].(*config.Workflow), testcase["msg"].(*dipper.Message), testcase["ctx"].(map[string]interface{}))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	testContinueFunc := func() {
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.ContinueSession(teststep["sessionID"].(string), teststep["msg"].(*dipper.Message), teststep["ctx"].([]map[string]interface{}))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	testResumeFunc := func() {
		baseLineNumGoRoutine = runtime.NumGoroutine()
		signal := make(chan int, 1)
		go func() {
			s.ResumeSession(teststep["key"].(string), teststep["msg"].(*dipper.Message))
			daemon.Children.Wait()
			signal <- 1
		}()
		select {
		case <-signal:
		case <-time.After(1 * time.Second):
			panic("timeout")
		}
	}

	for casenum, testcase = range hookTestCases {
		mockHelper = mock_workflow.NewMockSessionStoreHelper(ctrl)
		s.Helper = mockHelper
		mockHelper.EXPECT().GetConfig().AnyTimes().Return(testConfig)
		if assertFunc, ok := testcase["asserts"]; ok {
			assertFunc.(func())()
		}
		if shouldPanic, ok := testcase["panic"]; ok && shouldPanic.(bool) {
			assert.Panics(t, testStartFunc, "expecting panic at starting case %d", casenum)
		} else {
			assert.NotPanics(t, testStartFunc, "expecting not panic at starting case %d", casenum)
		}

		testSteps := testcase["steps"].([]map[string]interface{})
		for step, teststep = range testSteps {
			mockHelper = mock_workflow.NewMockSessionStoreHelper(ctrl)
			s.Helper = mockHelper
			mockHelper.EXPECT().GetConfig().AnyTimes().Return(testConfig)
			if assertFunc, ok := teststep["asserts"]; ok {
				assertFunc.(func())()
			}
			nextFunc := testContinueFunc
			if resuming, ok := teststep["resuming"]; ok && resuming.(bool) {
				nextFunc = testResumeFunc
			}
			if shouldPanic, ok := teststep["panic"]; ok && shouldPanic.(bool) {
				assert.Panics(t, nextFunc, "expecting panic at case %d step %d", casenum, step)
			} else {
				assert.NotPanics(t, nextFunc, "expecting not panic at case %d step %d", casenum, step)
			}
		}
		assert.Equal(t, len(testSteps)-1, step, "expecting number of processed steps at case %d", casenum)
		assert.Equal(t, 0, len(s.sessions), "expecting all session to be completed after case %d", casenum)
	}

	_ = baseLineNumGoRoutine
}
